<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- å…³é”®ï¼šç¦æ­¢ç”¨æˆ·ç¼©æ”¾ï¼Œè®¾ç½®è§†å£å®½åº¦ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minesweeper Win7 Mobile</title>
    <style>
        /* ============ CSS æ ·å¼ ============ */
        body {
            background-color: #f0f0f0;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden; /* é˜²æ­¢é¡µé¢æ»šåŠ¨ */
            user-select: none;
            -webkit-user-select: none;
            cursor: default;
            /* æ¶ˆé™¤ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
            -webkit-tap-highlight-color: transparent;
        }

        /* ç¼©æ”¾å®¹å™¨ï¼šç”¨äºæ•´ä½“ç¼©æ”¾æ¸¸æˆçª—å£ */
        #scaler {
            transform-origin: center center;
            transition: transform 0.2s ease-out;
        }

        #game-window {
            background: linear-gradient(to bottom, #eef3fa 0%, #d4e3f3 100%);
            border: 1px solid #688caf;
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            padding: 3px;
            display: inline-block;
        }

        /* èœå•æ  - æ‰‹æœºç«¯åŠ å¤§ä¸€ç‚¹ç‚¹å‡»åŒºåŸŸ */
        .menubar {
            font-size: 14px;
            color: #000;
            padding: 5px;
            background: transparent;
            margin-bottom: 2px;
            display: flex;
            gap: 15px;
        }
        .menubar span {
            cursor: pointer;
            padding: 2px 6px;
        }
        .menubar span:active {
            color: #0066cc;
            background-color: rgba(255,255,255,0.5);
            border-radius: 2px;
        }

        .game-panel {
            background-color: #c0c0c0;
            border-left: 2px solid #fff; border-top: 2px solid #fff;
            border-right: 2px solid #808080; border-bottom: 2px solid #808080;
            padding: 5px;
        }

        /* å¤´éƒ¨ï¼šä¿®å¤äº†å¯¹é½é—®é¢˜ */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 2px solid #808080; border-top: 2px solid #808080;
            border-right: 2px solid #fff; border-bottom: 2px solid #fff;
            padding: 4px 7px;
            margin-bottom: 5px;
            background: #c0c0c0;
            height: 30px;
        }

        .counter {
            background-color: #000; color: #ff0000;
            font-family: "Courier New", Courier, monospace;
            font-weight: bold; font-size: 24px; line-height: 24px;
            padding: 1px; width: 42px; text-align: right;
            border-left: 1px solid #808080; border-top: 1px solid #808080;
            border-right: 1px solid #fff; border-bottom: 1px solid #fff;
            letter-spacing: 1px;
            height: 24px; 
            box-sizing: content-box; 
        }

        /* ç¬‘è„¸æŒ‰é’® - Flexå±…ä¸­ */
        #face-btn {
            width: 26px; height: 26px;
            border: 1px solid #808080; outline: none;
            background: #c0c0c0;
            display: flex; justify-content: center; align-items: center;
            padding: 0; margin: 0;
            font-size: 18px; cursor: pointer;
            border-left: 1px solid #fff; border-top: 1px solid #fff;
            border-right: 1px solid #808080; border-bottom: 1px solid #808080;
            box-shadow: inset 1px 1px 0 #fff;
        }
        #face-btn:active {
            border-left: 1px solid #808080; border-top: 1px solid #808080;
            border-right: 1px solid #fff; border-bottom: 1px solid #fff;
            box-shadow: none;
            padding-top: 2px; padding-left: 2px;
        }

        #grid {
            display: grid;
            border-left: 3px solid #808080; border-top: 3px solid #808080;
            border-right: 3px solid #fff; border-bottom: 3px solid #fff;
            touch-action: none; /* ç¦æ­¢æµè§ˆå™¨é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼ˆæ»šåŠ¨ç¼©æ”¾ï¼‰ */
        }

        .cell {
            width: 16px; height: 16px; line-height: 16px; text-align: center;
            font-size: 12px; font-weight: 900;
            background: #c0c0c0;
            border-left: 2px solid #fff; border-top: 2px solid #fff;
            border-right: 2px solid #808080; border-bottom: 2px solid #808080;
        }
        
        /* è§¦æ‘¸åé¦ˆæ ·å¼ */
        .cell.pressed {
            border: none; width: 20px; height: 20px;
            background: #bdbdbd;
        }

        .cell.open {
            border: 1px solid #777; width: 18px; height: 18px; background: #c0c0c0;
        }

        /* é¢œè‰²å®šä¹‰ */
        .c1 { color: blue; } .c2 { color: green; } .c3 { color: red; }
        .c4 { color: darkblue; } .c5 { color: darkred; } .c6 { color: darkcyan; }
        .c7 { color: black; } .c8 { color: gray; }

        .cell.mine { background-color: #c0c0c0; }
        .cell.mine-exploded { background-color: red; border: 1px solid #777; width: 18px; height: 18px; }
        .cell.flag { color: red; }
        .cell.wrong-mine { position: relative; }
        .cell.wrong-mine::after {
            content: "âŒ"; color: red; font-size: 14px; position: absolute;
            left: -1px; top: 0; width: 100%; height: 100%;
        }
    </style>
</head>
<body>

    <!-- å¢åŠ ä¸€ä¸ªç¼©æ”¾å±‚ -->
    <div id="scaler">
        <div id="game-window">
            <div class="menubar">
                <span onclick="setDifficulty('beginner')">åˆçº§</span>
                <span onclick="setDifficulty('intermediate')">ä¸­çº§</span>
                <span onclick="setDifficulty('expert')">é«˜çº§</span>
            </div>
            
            <div class="game-panel">
                <div class="header">
                    <div id="mine-count" class="counter">010</div>
                    <button id="face-btn">ğŸ˜Š</button>
                    <div id="timer" class="counter">000</div>
                </div>
                <div id="grid"></div>
            </div>
        </div>
    </div>

<script>
    const CONFIG = {
        beginner: { rows: 9, cols: 9, mines: 10 },
        intermediate: { rows: 16, cols: 16, mines: 40 },
        expert: { rows: 16, cols: 30, mines: 99 }
    };

    let currentConfig = CONFIG.beginner;
    let gridData = [];
    let isGameOver = false;
    let isFirstClick = true;
    let timerInterval = null;
    let timeElapsed = 0;
    let flagsUsed = 0;
    let cellsOpened = 0;

    // é¼ æ ‡çŠ¶æ€ï¼ˆæ¡Œé¢ç«¯ï¼‰
    let isLeftDown = false;
    let isRightDown = false;
    let isDualActionTriggered = false;

    // è§¦æ‘¸çŠ¶æ€ï¼ˆç§»åŠ¨ç«¯ï¼‰
    let longPressTimer = null;
    let isTouchMove = false;
    const LONG_PRESS_DURATION = 350; // é•¿æŒ‰åˆ¤å®šæ—¶é—´(ms)

    const gridEl = document.getElementById('grid');
    const mineCountEl = document.getElementById('mine-count');
    const timerEl = document.getElementById('timer');
    const faceBtn = document.getElementById('face-btn');
    const scalerEl = document.getElementById('scaler');
    const gameWindowEl = document.getElementById('game-window');

    function initGame(configName = null) {
        if (configName) currentConfig = CONFIG[configName];
        
        isGameOver = false;
        isFirstClick = true;
        timeElapsed = 0;
        flagsUsed = 0;
        cellsOpened = 0;
        gridData = [];
        
        // Reset states
        isLeftDown = false; isRightDown = false; isDualActionTriggered = false;
        isTouchMove = false;

        clearInterval(timerInterval);
        timerEl.innerText = "000";
        updateMineCount();
        faceBtn.innerText = "ğŸ˜Š";

        // ç”Ÿæˆç½‘æ ¼
        gridEl.style.gridTemplateColumns = `repeat(${currentConfig.cols}, 20px)`;
        gridEl.style.gridTemplateRows = `repeat(${currentConfig.rows}, 20px)`;
        gridEl.innerHTML = '';

        for (let r = 0; r < currentConfig.rows; r++) {
            for (let c = 0; c < currentConfig.cols; c++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.r = r;
                cell.dataset.c = c;
                gridEl.appendChild(cell);

                gridData.push({
                    r, c,
                    isMine: false, isOpen: false, isFlagged: false, neighborMines: 0,
                    element: cell
                });
            }
        }
        
        // æ¸¸æˆåˆå§‹åŒ–åï¼Œç«‹å³é€‚åº”å±å¹•
        setTimeout(fitToScreen, 10);
    }

    /**
     * é€‚é…å±å¹•ï¼šè®¡ç®—ç¼©æ”¾æ¯”ä¾‹
     */
    function fitToScreen() {
        const padding = 20;
        const screenW = window.innerWidth - padding;
        const screenH = window.innerHeight - padding;
        const gameW = gameWindowEl.offsetWidth;
        const gameH = gameWindowEl.offsetHeight;

        // è®¡ç®—å®½å’Œé«˜çš„ç¼©æ”¾æ¯”ä¾‹ï¼Œå–è¾ƒå°å€¼ä»¥å®Œå…¨å®¹çº³
        let scale = Math.min(screenW / gameW, screenH / gameH);
        
        // æ¡Œé¢ç«¯å¦‚æœä¸è¶…å‡ºå±å¹•ï¼Œä¸è¦æ”¾å¤§è¶…è¿‡ 1.5 å€ï¼Œå¦åˆ™å¤ªç³Š
        // ç§»åŠ¨ç«¯é€šå¸¸å…è®¸æ”¾å¤§å¡«æ»¡å®½åº¦
        if (scale > 2.5) scale = 2.5; 
        
        // å¦‚æœå±å¹•è¶³å¤Ÿå¤§ï¼ˆæ¯”å¦‚ç”µè„‘å…¨å±ï¼‰ï¼Œä¸è¦è®©å®ƒå¤ªå°ï¼Œè‡³å°‘ä¿æŒ1
        // ä½†å¦‚æœå±å¹•å¾ˆå°ï¼ˆæ‰‹æœºï¼‰ï¼Œscaleå¯èƒ½ä¼šå°äº1ï¼ˆå¦‚æœåˆ—æ•°å¾ˆå¤šï¼‰æˆ–è€…å¤§äº1
        
        scalerEl.style.transform = `scale(${scale})`;
    }
    
    // ç›‘å¬çª—å£å¤§å°æ”¹å˜
    window.addEventListener('resize', fitToScreen);
    window.setDifficulty = function(level) { initGame(level); }


    /* ================= äº¤äº’é€»è¾‘ (å…¼å®¹é¼ æ ‡ä¸è§¦æ‘¸) ================= */

    // ç¦ç”¨å³é”®èœå•
    gridEl.addEventListener('contextmenu', e => e.preventDefault());

    // ------------------ é¼ æ ‡äº‹ä»¶ (Desktop) ------------------
    gridEl.addEventListener('mousedown', (e) => {
        if (isGameOver || !e.target.classList.contains('cell')) return;
        // å¿½ç•¥è§¦æ‘¸è§¦å‘çš„ mousedown (é˜²æ­¢é‡å¤)
        
        if (e.button === 0) isLeftDown = true;
        if (e.button === 2) isRightDown = true;
        if (e.button === 1) isDualActionTriggered = true; 

        faceBtn.innerText = "ğŸ˜®";
    });

    gridEl.addEventListener('mouseup', (e) => {
        if (isGameOver || !e.target.classList.contains('cell')) return;
        faceBtn.innerText = "ğŸ˜Š";
        const data = getCellData(e.target);

        // ä¸­é”®
        if (e.button === 1) {
            chord(data);
            isDualActionTriggered = false;
            return;
        }
        // åŒé”®æ¾å¼€é€»è¾‘
        if (isLeftDown && isRightDown) {
            isDualActionTriggered = true; 
            chord(data);
        }
        // å¤„ç†é”
        if (isDualActionTriggered) {
            if (e.button === 0) isLeftDown = false;
            if (e.button === 2) isRightDown = false;
            if (!isLeftDown && !isRightDown) isDualActionTriggered = false;
            return;
        }

        // å•ç‚¹é€»è¾‘
        if (e.button === 0) { // å·¦é”®
            isLeftDown = false;
            handleLeftClick(data);
        } else if (e.button === 2) { // å³é”®
            isRightDown = false;
            handleRightClick(data);
        }
    });
    
    // é¼ æ ‡ç§»å‡ºé‡ç½®
    gridEl.addEventListener('mouseleave', () => {
        isLeftDown = false; isRightDown = false; faceBtn.innerText = "ğŸ˜Š";
    });


    // ------------------ è§¦æ‘¸äº‹ä»¶ (Mobile) ------------------
    // é€»è¾‘ï¼šçŸ­æŒ‰=å·¦é”®ï¼Œé•¿æŒ‰=å³é”®ï¼Œç‚¹å‡»æ•°å­—=åŒé”®æ¢é›·
    
    gridEl.addEventListener('touchstart', (e) => {
        if (isGameOver || !e.target.classList.contains('cell')) return;
        const cell = e.target;
        const data = getCellData(cell);
        
        isTouchMove = false;
        faceBtn.innerText = "ğŸ˜®";
        
        // è§†è§‰åé¦ˆ
        if (!data.isOpen && !data.isFlagged) cell.classList.add('pressed');

        // é•¿æŒ‰è®¡æ—¶å™¨
        longPressTimer = setTimeout(() => {
            // é•¿æŒ‰è§¦å‘ï¼šæ’æ——
            if (!isTouchMove) {
                navigator.vibrate && navigator.vibrate(50); // éœ‡åŠ¨åé¦ˆ
                handleRightClick(data);
                isTouchMove = true; // æ ‡è®°å·²å¤„ç†ï¼Œé˜²æ­¢ touchend å†æ¬¡è§¦å‘å·¦é”®
                cell.classList.remove('pressed');
                faceBtn.innerText = "ğŸ˜Š";
            }
        }, LONG_PRESS_DURATION);
    }, {passive: false});

    gridEl.addEventListener('touchmove', (e) => {
        // å¦‚æœæ‰‹æŒ‡ç§»åŠ¨äº†ï¼Œå–æ¶ˆé•¿æŒ‰ï¼Œä¹Ÿå–æ¶ˆç‚¹å‡»
        isTouchMove = true;
        clearTimeout(longPressTimer);
        const cell = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
        // ç®€å•çš„è§†è§‰å¤„ç†ï¼šå¦‚æœç§»å‡ºåŸæœ¬æ ¼å­ï¼Œç§»é™¤ pressed
        // è¿™é‡Œç•¥è¿‡å¤æ‚çš„ DOM æŸ¥æ‰¾ä¼˜åŒ–
    }, {passive: false});

    gridEl.addEventListener('touchend', (e) => {
        if (isGameOver) return;
        e.preventDefault(); // é˜»æ­¢åç»­çš„ mouse äº‹ä»¶
        clearTimeout(longPressTimer);
        faceBtn.innerText = "ğŸ˜Š";
        
        // ç§»é™¤è§†è§‰åé¦ˆ
        const cells = gridEl.querySelectorAll('.pressed');
        cells.forEach(c => c.classList.remove('pressed'));

        if (!isTouchMove && e.target.classList.contains('cell')) {
            const data = getCellData(e.target);
            // çŸ­æŒ‰é€»è¾‘
            handleLeftClick(data); 
        }
    });


    /* ================= æ¸¸æˆæ ¸å¿ƒé€»è¾‘ ================= */

    function handleLeftClick(data) {
        if (data.isFlagged) return;

        // å¦‚æœç‚¹å‡»çš„æ˜¯å·²æ‰“å¼€çš„æ•°å­— -> è§¦å‘æ¢é›· (Mobile æ ¸å¿ƒäº¤äº’)
        if (data.isOpen && data.neighborMines > 0) {
            chord(data);
            return;
        }

        if (isFirstClick) {
            startTimer();
            placeMines(data.r, data.c);
            isFirstClick = false;
            const newData = getCellData(data.element);
            openCell(newData);
        } else {
            if (data.isMine) explode(data);
            else openCell(data);
        }
    }

    function handleRightClick(data) {
        if (!data.isOpen) toggleFlag(data);
    }

    function getCellData(element) {
        const r = parseInt(element.dataset.r);
        const c = parseInt(element.dataset.c);
        return gridData[r * currentConfig.cols + c];
    }

    function openCell(data) {
        if (data.isOpen || data.isFlagged) return;
        data.isOpen = true;
        cellsOpened++;
        data.element.classList.add('open');
        data.element.classList.remove('pressed');
        
        if (data.neighborMines > 0) {
            data.element.innerText = data.neighborMines;
            data.element.classList.add('c' + data.neighborMines);
        } else {
            const neighbors = getNeighbors(data);
            neighbors.forEach(n => {
                if(!n.isOpen && !n.isFlagged) openCell(n);
            });
        }
        checkWin();
    }

    function toggleFlag(data) {
        if (data.isFlagged) {
            data.isFlagged = false;
            data.element.classList.remove('flag');
            data.element.innerText = '';
            flagsUsed--;
        } else {
            data.isFlagged = true;
            data.element.classList.add('flag');
            data.element.innerText = 'ğŸš©';
            flagsUsed++;
        }
        updateMineCount();
    }

    function chord(data) {
        if (!data.isOpen || data.neighborMines === 0) return;
        const neighbors = getNeighbors(data);
        const flagCount = neighbors.filter(n => n.isFlagged).length;

        if (flagCount === data.neighborMines) {
            // ç®€å•è§†è§‰åé¦ˆï¼šé—ªçƒä¸€ä¸‹å‘¨å›´
            neighbors.forEach(n => {
                if(!n.isOpen && !n.isFlagged) {
                     n.element.classList.add('pressed');
                     setTimeout(()=>n.element.classList.remove('pressed'), 150);
                }
            });
            
            neighbors.forEach(n => {
                if (!n.isOpen && !n.isFlagged) {
                    if (n.isMine) explode(n);
                    else openCell(n);
                }
            });
        }
    }

    function placeMines(safeR, safeC) {
        let minesPlaced = 0;
        const totalCells = currentConfig.rows * currentConfig.cols;
        while (minesPlaced < currentConfig.mines) {
            const idx = Math.floor(Math.random() * totalCells);
            const r = Math.floor(idx / currentConfig.cols);
            const c = idx % currentConfig.cols;
            if (gridData[idx].isMine || (Math.abs(r-safeR)<=1 && Math.abs(c-safeC)<=1)) continue;
            gridData[idx].isMine = true;
            minesPlaced++;
        }
        for (let i = 0; i < gridData.length; i++) {
            if (!gridData[i].isMine) gridData[i].neighborMines = countNeighbors(gridData[i].r, gridData[i].c);
        }
    }

    function countNeighbors(r, c) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                if (i===0 && j===0) continue;
                const nr = r+i, nc = c+j;
                if (nr>=0 && nr<currentConfig.rows && nc>=0 && nc<currentConfig.cols) {
                    if (gridData[nr*currentConfig.cols+nc].isMine) count++;
                }
            }
        }
        return count;
    }

    function getNeighbors(data) {
        const arr = [];
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                if (i===0 && j===0) continue;
                const nr = data.r + i, nc = data.c + j;
                if (nr>=0 && nr<currentConfig.rows && nc>=0 && nc<currentConfig.cols) {
                    arr.push(gridData[nr*currentConfig.cols+nc]);
                }
            }
        }
        return arr;
    }

    function explode(data) {
        isGameOver = true;
        clearInterval(timerInterval);
        faceBtn.innerText = "ğŸ˜µ";
        data.element.classList.add('mine-exploded');
        data.element.innerText = 'ğŸ’£';
        gridData.forEach(cell => {
            if (cell.isMine && !cell.isFlagged && cell !== data) {
                cell.element.classList.add('mine', 'open');
                cell.element.innerText = 'ğŸ’£';
            }
            if (!cell.isMine && cell.isFlagged) {
                cell.element.classList.add('wrong-mine', 'open');
            }
        });
    }

    function checkWin() {
        if (cellsOpened === currentConfig.rows * currentConfig.cols - currentConfig.mines) {
            isGameOver = true;
            clearInterval(timerInterval);
            faceBtn.innerText = "ğŸ˜";
            mineCountEl.innerText = "000";
            gridData.forEach(cell => {
                if (cell.isMine && !cell.isFlagged) {
                    cell.element.classList.add('flag');
                    cell.element.innerText = 'ğŸš©';
                }
            });
        }
    }

    function startTimer() {
        timerInterval = setInterval(() => {
            timeElapsed++;
            if (timeElapsed > 999) timeElapsed = 999;
            timerEl.innerText = timeElapsed.toString().padStart(3, '0');
        }, 1000);
    }

    function updateMineCount() {
        let count = currentConfig.mines - flagsUsed;
        if (count < -99) count = -99;
        let str = Math.abs(count).toString().padStart(3, '0');
        if (count < 0) str = "-" + Math.abs(count).toString().padStart(2, '0');
        mineCountEl.innerText = str;
    }
    
    faceBtn.addEventListener('click', () => initGame(null));
    // é˜»æ­¢ç¬‘è„¸åŒå‡»ç¼©æ”¾
    faceBtn.addEventListener('touchstart', (e) => e.stopPropagation());

    initGame();

</script>
</body>
</html>